---
title: State Management
sidebar:
  order: 1
---

In a Tauri application, you often need to keep track of the current state of your application or manage the lifecycle of things associated with it. Tauri provides an easy way to manage the state of your application using the `Manager` API, and read it when commands are called.

Here is a simple example:

```rust
use tauri::{Builder, Manager};

struct AppData {
  welcome_message: &'static str,
}

// In `fn main()`:
Builder::default()
  .setup(|app| {
    app.manage(AppData {
      welcome_message: "Welcome to Tauri!",
    });
    Ok(())
  })
  .run(tauri::generate_context!())
  .unwrap();
```

You can later access your state via the `App` instance:

```rust
let data = app.state::<AppData>();
```

For accessing state in commands, see the [Accessing State](#accessing-state) section.

## Mutability

In Rust, values which can be shared between multiple owners (for example, sent to different threads) cannot be mutable. This is to prevent multiple owners from modifying the value at the same time, which can lead to issues such as data races.

To work around this, you can use the standard library's `Mutex` to wrap your state. This allows you to lock the value when you need to modify it, and unlock it when you are done.

```rust
use std::sync::Mutex;

use tauri::{Builder, Manager};

#[derive(Default)]
struct AppState {
  counter: u32,
}

// In `fn main()`:
Builder::default()
  .setup(|app| {
    app.manage(Mutex::new(AppState::default()));
    Ok(())
  })
  .run(tauri::generate_context!())
  .unwrap();
```

The state can now be modified by locking the mutex:

```rust
let state = app.state::<Mutex<AppState>>();

// Lock the mutex to get mutable access:
let mut state = state.lock().unwrap();

// Modify the state:
state.counter += 1;
```

At the end of the scope, or when the `MutexGuard` is otherwise dropped, the mutex is unlocked automatically so that other parts of your application can access and mutate the data within.

## Accessing State

You are now storing state in your application, but the obvious next question would be how to access the state in commands.

To build on the previous example, this is how you can access state (and optionally modify it) within commands:

```rust
use tauri::State;

#[tauri::command]
fn increase_counter(state: State<'_, Mutex<AppState>>) -> u32 {
  let mut state = state.lock().unwrap();
  state.counter += 1;
  state.counter
}
```

For more information on commands, see [Calling Rust from the Frontend](/develop/calling-rust).

### Do you need `Arc`?

It's common to see `Arc` used in Rust to share ownership of a value across multiple threads. However, in Tauri, you typically don't need to use `Arc` to wrap your state's `Mutex` because the state is already internally managed and shared across threads.

The only time in which it would make sense to use `Arc` for your state is when you need to share the state across multiple parts of your application that are not managed by Tauri itself.

### Mismatching Types

:::caution
If you use the wrong type for the `State` parameter, you will get a runtime panic instead of compile time error.

For example, if you use `State<'_, AppState>` instead of `State<'_, Mutex<AppState>>`, there won't be any state managed with that type.
:::

If you prefer, you can wrap your state with a type alias to prevent this mistake:

```rust
use std::sync::Mutex;

#[derive(Default)]
struct AppStateInner {
  counter: u32,
}

type AppState = Mutex<AppStateInner>;
```

However, make sure not to wrap it in a `Mutex` twice if you do this, otherwise you will run into the same issue.

### Async Mutex

To quote the [Tokio documentation](https://docs.rs/tokio/latest/tokio/sync/struct.Mutex.html#which-kind-of-mutex-should-you-use), it's usually fine to use the standard library's `Mutex`:

> Contrary to popular belief, it is ok and often preferred to use the ordinary Mutex from the standard library in asynchronous code ... The primary use case for the async mutex is to provide shared mutable access to IO resources such as a database connection.

It's a good idea to read the linked documentation page fully to understand the trade-offs between the two. However, if you are using `async` commands and want to use Tokio's async `Mutex`, you can set it up the same way and access the state like this:

```rust
use tauri::{async_runtime::Mutex, State};

#[tauri::command]
async fn increase_counter(state: State<'_, Mutex<AppState>>) -> Result<u32, ()> {
  let mut state = state.lock().await;
  state.counter += 1;
  Ok(state.counter)
}
```

Note that the return type must be `Result` if you use asynchronous commands.
